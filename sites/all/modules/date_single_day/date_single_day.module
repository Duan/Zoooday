<?php
/**
 * @file date_single_day.module
 * Alter CCK date fields.
 */

/**
 * Implementation of hook_widget_settings_alter().
 *
 * Add our checkbox to date popup field settings.
 *
 * Cribbed from http://www.gizra.com/content/hookwidgetsettingsalter-and-pandora
 */
function date_single_day_widget_settings_alter(&$settings, $op, $widget) {
  $widget_types = array('date_popup', 'date_popup_repeat');
  if ((!empty($widget['type']) && in_array($widget['type'], $widget_types)) || (!empty($widget['widget_type']) && in_array($widget['widget_type'], $widget_types))) {
    switch ($op) {
      case 'form':
        $settings['input']['single_day'] = array(
          '#type' => 'checkbox',
          '#title' => t('Show single day'),
          '#description' => t("Show only the time portion of the 'To' field. Use this for dates which will only ever span a single day."),
          '#default_value' => !empty($widget['single_day']),
        );

        break;
      case 'save':
        $settings[] = 'single_day';
        break;
    }
  }
}

/**
 * Implementation of hook_form_alter().
 */
function date_single_day_form_alter(&$form, $form_state, $form_id) {  
  // Alter node edit forms.
  if (isset($form['type']) && $form['type']['#value'] . '_node_form' == $form_id) {
    // Get fields on this node type.
    $fields = content_fields(NULL, $form['type']['#value']);
    
    foreach ($fields as $field_name => $field) {
      // Alter fields with the single_day setting.
      if (!empty($field['widget']['single_day'])) {
        // @todo: support fields in fieldgroups.
        if (isset($form[$field_name])) {
          // Use after_build to go after CCK does its magic in the #process step.
          // Handle regular dates and repeating dates separately.
          switch ($field['widget']['type']) {
            case 'date_popup':
              // Regular date pop-up.
              // Alter each value of a potentially multiple valued field.
              // Note we don't use element_children() because that catches the
              // 'add more' button.
              foreach (array_keys($form[$field_name]) as $key) {
                if (is_numeric($key)) {
                  $form[$field_name][$key]['#after_build'][] = 'date_single_day_after_build';
                  $form[$field_name][$key]['#theme'][] = 'date_single_day_element';
                }
              }
              break;
            case 'date_popup_repeat':
              // Date pop-up with repeat options.
              $form[$field_name]['#after_build'][] = 'date_single_day_after_build';
              $form[$field_name]['#theme'][] = 'date_single_day_element';
          }
        }
      }
    }
  }
  // Alter AJAX forms produced by the 'Add another item' button.
  elseif ($form_id == 'content_add_more_js') {
    foreach ($form as $field_name => $field) {
      foreach (array_keys($form[$field_name]) as $key) {
        if (is_numeric($key)) {
          if (isset($form[$field_name][$key]['#type']) && in_array($form[$field_name][$key]['#type'], array('date_popup', 'date_combo'))) {
            $content_fields = content_fields(NULL, $form[$field_name][$key]['#type']);
            if (!empty($content_fields[$field_name]['widget']['single_day'])) {
              $form[$field_name][$key]['#after_build'][] = 'date_single_day_after_build';
              $form[$field_name][$key]['#theme'][] = 'date_single_day_element';
            }
          }
        }
      }
    }
  }
}

/**
 * After_build for the date field.
 */
function date_single_day_after_build($form, &$form_state) {
  //dsm($form);
  
  // Hide the 'To' date element. 
  // 'hidden' works; 'value' does not.
  $form['value2']['date']['#type'] = 'hidden';
  $form['value2']['date']['#value'] = '';
  $form['#value']['value2']['date'] = '';
  
  // Put our validation first.
  // array_push($form['value2']['#element_validate'], 'date_single_day_validate');

  return $form;
}

/*
// The plan here was to intercept validation before date_popup's own
// validation and set the value of the to date to the same as the from date.
// However, there seems to be no sign whatsoever of the to time value!
function date_single_day_validate($element, &$form_state) {
  dsm($form_state);
  // the time doens't get here/
  if (1) {
   // form_error($element, t('boogaloo.'));
  }
}
*/

/**
 * Theme the date field elements.
 */
function theme_date_single_day_element($form) {
  //dsm($form);
  
  // Cascade the required value down into the subcomponent for theme_form_element to find it.
  if ($form['#required']) {
    $form['value']['date']['#required'] = TRUE;
  }

  $output = '';
  // Container to float the date and two times together.
  $output .= '<div class="container-inline-date">';
  $output .= '<div class="form-item">';

  // Render the 'from' date
  // Set titles in the individual form elements.
  $form['value']['date']['#title'] = t('Date');
  $output .= drupal_render($form['value']['date']);
  
  $form['value']['time']['#title'] = t('From time');
  $output .= drupal_render($form['value']['time']);
  
  $output .= drupal_render($form['value2']['date']);
  
  $form['value2']['time']['#title'] = t('To time');
  $output .= drupal_render($form['value2']['time']);

  // Spoof the #printed flag so drupal_render() thinks these are all done;
  // otherwise it renders their original labels.
  $form['value']['#printed'] = TRUE;
  $form['value2']['#printed'] = TRUE;

  $output .= '</div>';
  $output .= '</div>';

  // Render whatever is left in the form, eg repeat rule, timezone.
  foreach (element_children($form) as $key) {
    $output .= drupal_render($form[$key]);
  }
  
  return $output;
}

/**
 * Implementation of hook_theme().
 */
function date_single_day_theme($existing, $type, $theme, $path) {
  return array(
    'date_single_day_element' => array(
      'arguments' => array('arg1' => NULL, 'arg2' => 0, 'arg3' => FALSE),
    ),
  );
}

